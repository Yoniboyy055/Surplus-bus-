# Adversarial Abuse Test - Round 2

| Scenario | How the Abuse Happens (Step-by-Step) | Why the Current Design Allows It | The SMALLEST Possible Fix (SQL/RLS/Trigger/Guard) |
| :--- | :--- | :--- | :--- |
| **1. Payout Double-Dip** | A malicious operator (or system bug) marks a payout as `paid` in the `payouts` table, but the deal status remains `WON_PENDING_CLOSE`. The operator then re-verifies the deal, which triggers a second `CLOSED_PAID` status update and a second payout record insertion (if the automation is not idempotent). | The `payouts` table does not have a unique constraint on `deal_id` to prevent multiple payout records for the same deal. The automation logic is not visible but is assumed to be non-idempotent. | **SQL Constraint:** Add a unique constraint on `payouts(deal_id)` where `status = 'pending'` or `status = 'paid'`. Better: Add a unique constraint on `payouts(deal_id)` and enforce that only one record can exist per deal. |
| **2. Buyer Track Downgrade Bypass** | A buyer is downgraded to Track B due to reputation. They then create a new profile with a new email (which is allowed by Supabase Auth) and submit a new deal, immediately starting as a fresh Track B (or Track A if the default is Track A). | The `buyers` table is linked to `profiles.id` (UUID), which is tied to the Supabase Auth user. There is no mechanism to link multiple user accounts to the same physical person (e.g., by phone number or name hash). | **Policy/UI Only:** Enforce mandatory phone number or ID verification on sign-up and add a `UNIQUE` constraint on `profiles.phone`. **Server-Side Guard:** Implement a server-side check to prevent re-registration with the same phone/ID. |
| **3. Deal Status Rollback** | An operator, after marking a deal as `CLOSED_PAID`, attempts to revert the status to a previous state (e.g., `MATCHING`) to hide a successful deal or manipulate metrics. | The RLS policy in R1 only prevents *non-operators* from setting critical statuses, but does not prevent *operators* from setting invalid status transitions (e.g., from `CLOSED_PAID` back to `NEW_SUBMISSION`). | **SQL Trigger/Function:** Implement a PostgreSQL function that checks `old.status` and `new.status` against a predefined valid state machine transition table (e.g., `CLOSED_PAID` can only transition to `ARCHIVED` or `FAILED_AUDIT`, not to a prior state). |
| **4. Referrer Commission Manipulation** | A referrer, knowing the commission rate is tied to their `tier` at the time of deal creation, attempts to rapidly increase their tier (e.g., by gaming the points system) just before a high-value deal is created, to lock in a higher `referrer_fee_split_percent` on the `deals` table. | The `deals.referrer_fee_split_percent` is set at deal creation, but the `referrers.tier` can change dynamically. If the deal creation logic is not atomic, a race condition could allow a higher tier to be snapshot just before the deal is inserted. | **Server-Side Guard:** Ensure the logic that reads `referrers.commission_rate` and inserts the `deals` record is wrapped in a database transaction to guarantee atomicity and prevent race conditions. |
| **5. Audit Log Tampering** | An operator, who has final authority, makes a controversial decision (e.g., rejecting a deal that should have been qualified) and then attempts to delete or modify the corresponding entry in the `audit_logs` table to cover their tracks. | The `audit_logs` table is likely writable by the operator role, and there is no RLS policy preventing `DELETE` or `UPDATE` on the logs. | **RLS Policy:** Add an RLS policy on the `audit_logs` table that prevents `UPDATE` and `DELETE` operations for all roles, including `operator`. Logs should be immutable once written. |
