# Adversarial Abuse Test - Round 3

| Scenario | How the Abuse Happens (Step-by-Step) | Why the Current Design Allows It | The SMALLEST Possible Fix (SQL/RLS/Trigger/Guard) |
| :--- | :--- | :--- | :--- |
| **1. Race Condition on Exclusive Window** | Buyer submits "Commit to Bid" at `T-1ms` before `exclusive_ends_at`. Operator simultaneously submits "Reset Window" at `T-1ms`. If not atomic, one action could overwrite the other, leading to an invalid state (e.g., bid committed after expiration). | The application logic (server-side guard) for checking the window is not visible and is likely not using database-level locking for atomicity. | **Server-Side Guard/Transaction:** Any API route handling "Commit to Bid" or "Reset Window" MUST use a database transaction with `SELECT ... FOR UPDATE` on the `deals` row to ensure atomicity. |
| **2. High-Volume Referral Link Spam** | A malicious user repeatedly hits the unified form submission endpoint with fake data to consume system resources and potentially trigger unwanted `deal` records. | The unified form submission endpoint is not rate-limited, allowing a single user to generate high-volume, low-value spam. | **Server-Side Guard/Edge Function:** Implement a server-side rate-limiter (e.g., based on IP address or session ID) on the unified form submission endpoint to limit requests per minute. |
| **3. Buyer Track Snapshot Manipulation** | A buyer with a low reputation score is about to be downgraded. They quickly submit a new deal *before* the asynchronous reputation update is fully processed, snapshotting their current (higher) track in `deals.buyer_track_snapshot`. | The application logic for creating a deal and updating a buyer's track are likely separate calls, creating a window for a race condition under time pressure. | **Server-Side Guard:** Ensure the deal creation API route first calls a function to synchronously update the buyer's track/reputation (if needed) *before* taking the `buyer_track_snapshot` for the new deal record. |
| **4. Operator Payout Delay (Incentive Misalignment)** | An operator intentionally delays marking a deal as `CLOSED_PAID` to delay the referrer's payout, effectively using the commission as a short-term, interest-free loan. | The system has no mechanism to enforce a time limit between `WON_PENDING_CLOSE` and `CLOSED_PAID` (the verification step). | **Policy/UI Only:** Implement a clear SLA (e.g., 7 days) for verification in the Operator Portal UI. **SQL Trigger (Future):** Add a trigger to log an `audit_log` event if a deal remains in `WON_PENDING_CLOSE` for more than 7 days. |
| **5. Query Performance Degradation** | As the number of deals scales into the thousands, the Operator Dashboard queries based on `status` become slow, impacting the operator's ability to manage the pipeline efficiently. | The existing indexes are single-column. For high-volume status-based queries, a composite index is more efficient. | **SQL Index:** Add a composite index on the most frequently queried fields for the Operator Dashboard: `create index idx_deals_status_created_at on public.deals (status, created_at desc);` |
